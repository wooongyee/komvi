package com.github.wooongyee.komvi.processor

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.writeTo

/**
 * Generates dispatch extension functions for ViewModel.
 *
 * Generates two dispatch function overloads:
 * - dispatch(intent: ViewAction): for View layer
 * - dispatch(intent: Internal): for ViewModel internal use
 */
internal class DispatchCodeGenerator(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) {

    fun generate(
        viewModelClass: KSClassDeclaration,
        intentClass: KSClassDeclaration,
        handlers: List<HandlerInfo>
    ) {
        val packageName = viewModelClass.packageName.asString()
        val viewModelName = viewModelClass.simpleName.asString()
        val intentName = intentClass.simpleName.asString()

        val viewActionHandlers = handlers.filter { it.isViewAction }
        val internalHandlers = handlers.filter { !it.isViewAction }

        val viewActionDispatch = generateViewActionDispatch(
            viewModelClass, intentClass, viewActionHandlers
        )

        val internalDispatch = generateInternalDispatch(
            viewModelClass, intentClass, internalHandlers
        )

        val fileSpec = FileSpec.builder(packageName, "${viewModelName}_Dispatch")
            .addFileComment("Generated by Komvi KSP Processor")
            .addFileComment("DO NOT EDIT MANUALLY")
            .addAnnotation(
                com.squareup.kotlinpoet.AnnotationSpec.builder(
                    com.squareup.kotlinpoet.ClassName("kotlin", "OptIn")
                ).addMember("%T::class", com.squareup.kotlinpoet.ClassName("com.github.wooongyee.komvi.annotations", "InternalKomviApi"))
                .build()
            )
            .addFunction(viewActionDispatch)
            .addFunction(internalDispatch)
            .build()

        fileSpec.writeTo(codeGenerator, Dependencies(false, viewModelClass.containingFile!!))

        logger.info("Generated dispatch functions for $viewModelName")
    }

    private fun generateViewActionDispatch(
        viewModelClass: KSClassDeclaration,
        intentClass: KSClassDeclaration,
        handlers: List<HandlerInfo>
    ): FunSpec {
        val viewModelClassName = viewModelClass.toClassName()
        val viewModelName = viewModelClass.simpleName.asString()
        val intentPackageName = intentClass.packageName.asString()
        val intentName = intentClass.simpleName.asString()
        val viewActionTypeName = ClassName(intentPackageName, intentName, "ViewAction")

        return FunSpec.builder("dispatch")
            .receiver(viewModelClassName)
            .addParameter(ParameterSpec.builder("intent", viewActionTypeName).build())
            .addKdoc("Dispatches ViewAction intents from View layer")
            .beginControlFlow("when (intent)")
            .apply {
                handlers.forEach { handlerInfo ->
                    val function = handlerInfo.function
                    val handlerName = function.simpleName.asString()

                    // Get Intent type from parameter
                    val param = function.parameters.firstOrNull()
                    val paramType = param?.type?.resolve()?.declaration as? KSClassDeclaration
                    val intentSubclassName = paramType?.simpleName?.asString() ?: return@forEach

                    val log = handlerInfo.annotation.arguments
                        .find { it.name?.asString() == "log" }?.value as? Boolean ?: false
                    val executionMode = handlerInfo.executionMode
                    val handlerKey = "$viewModelName.$intentSubclassName"

                    beginControlFlow("is $intentName.ViewAction.$intentSubclassName ->")

                    if (log) {
                        beginControlFlow("if (this.debugMode)")
                        addStatement("this.logger.debug(%S, %S + intent)", viewModelName, "Intent received: ")
                        endControlFlow()
                    }
                    addStatement("val logicBlock = $handlerName(intent)")
                    addStatement("this.executeHandler(logicBlock, %S, %S)", executionMode, handlerKey)

                    endControlFlow()
                }
            }
            .endControlFlow()
            .build()
    }

    private fun generateInternalDispatch(
        viewModelClass: KSClassDeclaration,
        intentClass: KSClassDeclaration,
        handlers: List<HandlerInfo>
    ): FunSpec {
        val viewModelClassName = viewModelClass.toClassName()
        val viewModelName = viewModelClass.simpleName.asString()
        val intentPackageName = intentClass.packageName.asString()
        val intentName = intentClass.simpleName.asString()
        val internalTypeName = ClassName(intentPackageName, intentName, "Internal")

        return FunSpec.builder("dispatch")
            .receiver(viewModelClassName)
            .addParameter(ParameterSpec.builder("intent", internalTypeName).build())
            .addKdoc("Dispatches Internal intents within ViewModel")
            .beginControlFlow("when (intent)")
            .apply {
                handlers.forEach { handlerInfo ->
                    val function = handlerInfo.function
                    val handlerName = function.simpleName.asString()

                    // Get Intent type from parameter
                    val param = function.parameters.firstOrNull()
                    val paramType = param?.type?.resolve()?.declaration as? KSClassDeclaration
                    val intentSubclassName = paramType?.simpleName?.asString() ?: return@forEach

                    val log = handlerInfo.annotation.arguments
                        .find { it.name?.asString() == "log" }?.value as? Boolean ?: false
                    val executionMode = handlerInfo.executionMode
                    val handlerKey = "$viewModelName.$intentSubclassName"

                    beginControlFlow("is $intentName.Internal.$intentSubclassName ->")

                    if (log) {
                        beginControlFlow("if (this.debugMode)")
                        addStatement("this.logger.debug(%S, %S + intent)", viewModelName, "Intent received: ")
                        endControlFlow()
                    }
                    addStatement("val logicBlock = $handlerName(intent)")
                    addStatement("this.executeHandler(logicBlock, %S, %S)", executionMode, handlerKey)

                    endControlFlow()
                }
            }
            .endControlFlow()
            .build()
    }
}
