package io.github.wooongyee.komvi.processor

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.writeTo

/**
 * Generates dispatch extension functions for ViewModel.
 *
 * Generates two dispatch function overloads:
 * - dispatch(intent: ViewAction): for View layer
 * - dispatch(intent: Internal): for ViewModel internal use
 */
internal class DispatchCodeGenerator(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) {

    fun generate(
        viewModelClass: KSClassDeclaration,
        intentClass: KSClassDeclaration,
        handlers: List<HandlerInfo>
    ) {
        val packageName = viewModelClass.packageName.asString()
        val viewModelName = viewModelClass.simpleName.asString()
        val intentName = intentClass.simpleName.asString()

        val viewActionHandlers = handlers.filter { it.isViewAction }
        val internalHandlers = handlers.filter { !it.isViewAction }

        val viewActionDispatch = generateViewActionDispatch(
            viewModelClass, intentName, viewActionHandlers
        )

        val internalDispatch = generateInternalDispatch(
            viewModelClass, intentName, internalHandlers
        )

        val fileSpec = FileSpec.builder(packageName, "${viewModelName}_Dispatch")
            .addFileComment("Generated by Komvi KSP Processor")
            .addFileComment("DO NOT EDIT MANUALLY")
            .addAnnotation(
                com.squareup.kotlinpoet.AnnotationSpec.builder(
                    com.squareup.kotlinpoet.ClassName("kotlin", "OptIn")
                ).addMember("%T::class", com.squareup.kotlinpoet.ClassName("io.github.wooongyee.komvi.annotations", "InternalKomviApi"))
                .build()
            )
            .addFunction(viewActionDispatch)
            .addFunction(internalDispatch)
            .build()

        fileSpec.writeTo(codeGenerator, Dependencies(false, viewModelClass.containingFile!!))

        logger.info("Generated dispatch functions for $viewModelName")
    }

    private fun generateViewActionDispatch(
        viewModelClass: KSClassDeclaration,
        intentName: String,
        handlers: List<HandlerInfo>
    ): FunSpec {
        val viewModelClassName = viewModelClass.toClassName()
        val viewModelName = viewModelClass.simpleName.asString()
        val packageName = viewModelClass.packageName.asString()
        val viewActionTypeName = ClassName(packageName, "$intentName.ViewAction")

        return FunSpec.builder("dispatch")
            .receiver(viewModelClassName)
            .addParameter(ParameterSpec.builder("intent", viewActionTypeName).build())
            .addKdoc("Dispatches ViewAction intents from View layer")
            .beginControlFlow("when (intent)")
            .apply {
                handlers.forEach { handlerInfo ->
                    val function = handlerInfo.function
                    val subclassName = function.simpleName.asString().removePrefix("handle")
                    val handlerName = function.simpleName.asString()

                    val log = handlerInfo.annotation.arguments
                        .find { it.name?.asString() == "log" }?.value as? Boolean ?: false
                    val measurePerformance = handlerInfo.annotation.arguments
                        .find { it.name?.asString() == "measurePerformance" }?.value as? Boolean ?: false

                    beginControlFlow("is $intentName.ViewAction.$subclassName ->")

                    if (log) {
                        addStatement("android.util.Log.d(%S, %S + intent)", viewModelName, "Intent received: ")
                    }

                    if (measurePerformance) {
                        addStatement("val startTime = System.currentTimeMillis()")
                        addStatement("val logicBlock = $handlerName(intent)")
                        addStatement("this.executeHandler(logicBlock)")
                        addStatement("val duration = System.currentTimeMillis() - startTime")
                        addStatement("android.util.Log.d(%S, %S + duration + %S)", viewModelName, "Performance: $handlerName took ", "ms")
                    } else {
                        addStatement("val logicBlock = $handlerName(intent)")
                        addStatement("this.executeHandler(logicBlock)")
                    }

                    endControlFlow()
                }
            }
            .endControlFlow()
            .build()
    }

    private fun generateInternalDispatch(
        viewModelClass: KSClassDeclaration,
        intentName: String,
        handlers: List<HandlerInfo>
    ): FunSpec {
        val viewModelClassName = viewModelClass.toClassName()
        val viewModelName = viewModelClass.simpleName.asString()
        val packageName = viewModelClass.packageName.asString()
        val internalTypeName = ClassName(packageName, "$intentName.Internal")

        return FunSpec.builder("dispatch")
            .receiver(viewModelClassName)
            .addParameter(ParameterSpec.builder("intent", internalTypeName).build())
            .addKdoc("Dispatches Internal intents within ViewModel")
            .beginControlFlow("when (intent)")
            .apply {
                handlers.forEach { handlerInfo ->
                    val function = handlerInfo.function
                    val subclassName = function.simpleName.asString().removePrefix("handle")
                    val handlerName = function.simpleName.asString()

                    val log = handlerInfo.annotation.arguments
                        .find { it.name?.asString() == "log" }?.value as? Boolean ?: false
                    val measurePerformance = handlerInfo.annotation.arguments
                        .find { it.name?.asString() == "measurePerformance" }?.value as? Boolean ?: false

                    beginControlFlow("is $intentName.Internal.$subclassName ->")

                    if (log) {
                        addStatement("android.util.Log.d(%S, %S + intent)", viewModelName, "Intent received: ")
                    }

                    if (measurePerformance) {
                        addStatement("val startTime = System.currentTimeMillis()")
                        addStatement("val logicBlock = $handlerName(intent)")
                        addStatement("this.executeHandler(logicBlock)")
                        addStatement("val duration = System.currentTimeMillis() - startTime")
                        addStatement("android.util.Log.d(%S, %S + duration + %S)", viewModelName, "Performance: $handlerName took ", "ms")
                    } else {
                        addStatement("val logicBlock = $handlerName(intent)")
                        addStatement("this.executeHandler(logicBlock)")
                    }

                    endControlFlow()
                }
            }
            .endControlFlow()
            .build()
    }
}
